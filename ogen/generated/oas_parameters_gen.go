// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// BlockFromTimestampParams is parameters of BlockFromTimestamp operation.
type BlockFromTimestampParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// Unix timestamp - finds a block at or before the number of seconds since January 1, 1970.
	Timestamp float64
}

func unpackBlockFromTimestampParams(packed middleware.Parameters) (params BlockFromTimestampParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		params.Timestamp = packed[key].(float64)
	}
	return params
}

func decodeBlockFromTimestampParams(args [1]string, argsEscaped bool, r *http.Request) (params BlockFromTimestampParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToFloat64(val)
				if err != nil {
					return err
				}

				params.Timestamp = c
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(params.Timestamp)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// BlockToTimestampParams is parameters of BlockToTimestamp operation.
type BlockToTimestampParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// Block number.
	BlockNumber float64
}

func unpackBlockToTimestampParams(packed middleware.Parameters) (params BlockToTimestampParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		params.BlockNumber = packed[key].(float64)
	}
	return params
}

func decodeBlockToTimestampParams(args [1]string, argsEscaped bool, r *http.Request) (params BlockToTimestampParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToFloat64(val)
				if err != nil {
					return err
				}

				params.BlockNumber = c
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(params.BlockNumber)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// CrossChainBlockParams is parameters of CrossChainBlock operation.
type CrossChainBlockParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// Block number.
	BlockNumber float64
	// Cross chain ID.
	CrossChainId int
}

func unpackCrossChainBlockParams(packed middleware.Parameters) (params CrossChainBlockParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		params.BlockNumber = packed[key].(float64)
	}
	{
		key := middleware.ParameterKey{
			Name: "crossChainId",
			In:   "query",
		}
		params.CrossChainId = packed[key].(int)
	}
	return params
}

func decodeCrossChainBlockParams(args [1]string, argsEscaped bool, r *http.Request) (params CrossChainBlockParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToFloat64(val)
				if err != nil {
					return err
				}

				params.BlockNumber = c
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Float{}).Validate(float64(params.BlockNumber)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: crossChainId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "crossChainId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CrossChainId = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "crossChainId",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetCachedModelResultsParams is parameters of GetCachedModelResults operation.
type GetCachedModelResultsParams struct {
	// Model slug.
	Slug string
	// Field to sort results by: 'time', 'runtime'. Defaults to 'time'.
	Sort OptString
	// "asc" ascending order or "desc" descending order. Default is "desc".
	Order OptGetCachedModelResultsOrder
	// Maximum number of results to return. Defaults to 100.
	Limit OptFloat64
	// Offset index of results to return for pagination. Defaults to 0.
	Offset OptFloat64
}

func unpackGetCachedModelResultsParams(packed middleware.Parameters) (params GetCachedModelResultsParams) {
	{
		key := middleware.ParameterKey{
			Name: "slug",
			In:   "query",
		}
		params.Slug = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "sort",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sort = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "order",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Order = v.(OptGetCachedModelResultsOrder)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetCachedModelResultsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetCachedModelResultsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: slug.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "slug",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Slug = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "slug",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sort.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sort",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: order.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal GetCachedModelResultsOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = GetCachedModelResultsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Order.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "order",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Offset.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetDailyModelUsageParams is parameters of GetDailyModelUsage operation.
type GetDailyModelUsageParams struct {
	// Size of window in days [OPTIONAL]. Defaults to 90.
	Days OptFloat64
	// Group results by "model", "requester-model", "requester" [OPTIONAL]. Only used if `requester` is
	// not specified. Defaults to "model".
	GroupBy OptString
	// The NFT Id of the requester [OPTIONAL].
	Requester OptString
}

func unpackGetDailyModelUsageParams(packed middleware.Parameters) (params GetDailyModelUsageParams) {
	{
		key := middleware.ParameterKey{
			Name: "days",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Days = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "groupBy",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.GroupBy = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "requester",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Requester = v.(OptString)
		}
	}
	return params
}

func decodeGetDailyModelUsageParams(args [0]string, argsEscaped bool, r *http.Request) (params GetDailyModelUsageParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: days.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "days",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDaysVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotDaysVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Days.SetTo(paramsDotDaysVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Days.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "days",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: groupBy.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "groupBy",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotGroupByVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotGroupByVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.GroupBy.SetTo(paramsDotGroupByVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "groupBy",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: requester.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "requester",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRequesterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRequesterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Requester.SetTo(paramsDotRequesterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "requester",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetLatestBlockParams is parameters of GetLatestBlock operation.
type GetLatestBlockParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
}

func unpackGetLatestBlockParams(packed middleware.Parameters) (params GetLatestBlockParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	return params
}

func decodeGetLatestBlockParams(args [1]string, argsEscaped bool, r *http.Request) (params GetLatestBlockParams, _ error) {
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetModelBySlugParams is parameters of GetModelBySlug operation.
type GetModelBySlugParams struct {
	Slug string
}

func unpackGetModelBySlugParams(packed middleware.Parameters) (params GetModelBySlugParams) {
	{
		key := middleware.ParameterKey{
			Name: "slug",
			In:   "path",
		}
		params.Slug = packed[key].(string)
	}
	return params
}

func decodeGetModelBySlugParams(args [1]string, argsEscaped bool, r *http.Request) (params GetModelBySlugParams, _ error) {
	// Decode path: slug.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Slug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "slug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetModelDeploymentsBySlugParams is parameters of GetModelDeploymentsBySlug operation.
type GetModelDeploymentsBySlugParams struct {
	Slug string
}

func unpackGetModelDeploymentsBySlugParams(packed middleware.Parameters) (params GetModelDeploymentsBySlugParams) {
	{
		key := middleware.ParameterKey{
			Name: "slug",
			In:   "path",
		}
		params.Slug = packed[key].(string)
	}
	return params
}

func decodeGetModelDeploymentsBySlugParams(args [1]string, argsEscaped bool, r *http.Request) (params GetModelDeploymentsBySlugParams, _ error) {
	// Decode path: slug.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Slug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "slug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetPositionsParams is parameters of GetPositions operation.
type GetPositionsParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// Comma separated list of account addresses.
	Accounts []string
	// Comma separated list of token addresses. If no tokens are provided return positions for all tokens
	// with non-zero balances.
	Tokens []string
	// Block number of the portfolio. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetPositionsParams(packed middleware.Parameters) (params GetPositionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "accounts",
			In:   "path",
		}
		params.Accounts = packed[key].([]string)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokens",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Tokens = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetPositionsParams(args [2]string, argsEscaped bool, r *http.Request) (params GetPositionsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: accounts.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "accounts",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotAccountsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotAccountsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Accounts = append(params.Accounts, paramsDotAccountsVal)
					return nil
				})
			}(); err != nil {
				return err
			}
			if err := func() error {
				if params.Accounts == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "accounts",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: tokens.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tokens",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotTokensVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotTokensVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Tokens = append(params.Tokens, paramsDotTokensVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokens",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetPositionsHistoricalParams is parameters of GetPositionsHistorical operation.
type GetPositionsHistoricalParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// Comma separated list of account addresses.
	Accounts []string
	// Start block number. Required.
	StartBlockNumber OptFloat64
	// End block number of the balance. Defaults to the latest block.
	EndBlockNumber OptFloat64
	// Number of blocks between each data point.
	BlockInterval OptFloat64
	// Start timestamp of a block number can be specified instead of start block number. Finds a block at
	// or before the number of seconds since January 1, 1970.
	StartTimestamp OptFloat64
	// End timestamp of a block number can be specified instead of end block number. Finds a block at or
	// before the number of seconds since January 1, 1970.
	EndTimestamp OptFloat64
	// Can be specified instead of blockInterval. Should be in seconds. Defaults to 86,400.
	TimeInterval OptFloat64
	// Comma separated list of token addresses. If no tokens are provided return positions for all tokens
	// with non-zero balances.
	Tokens []string
}

func unpackGetPositionsHistoricalParams(packed middleware.Parameters) (params GetPositionsHistoricalParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "accounts",
			In:   "path",
		}
		params.Accounts = packed[key].([]string)
	}
	{
		key := middleware.ParameterKey{
			Name: "startBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockInterval = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "startTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timeInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TimeInterval = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "tokens",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Tokens = v.([]string)
		}
	}
	return params
}

func decodeGetPositionsHistoricalParams(args [2]string, argsEscaped bool, r *http.Request) (params GetPositionsHistoricalParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: accounts.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "accounts",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotAccountsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotAccountsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Accounts = append(params.Accounts, paramsDotAccountsVal)
					return nil
				})
			}(); err != nil {
				return err
			}
			if err := func() error {
				if params.Accounts == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "accounts",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: startBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartBlockNumber.SetTo(paramsDotStartBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndBlockNumber.SetTo(paramsDotEndBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockInterval.SetTo(paramsDotBlockIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockInterval",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: startTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTimestamp.SetTo(paramsDotStartTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndTimestamp.SetTo(paramsDotEndTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timeInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimeIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeInterval.SetTo(paramsDotTimeIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.TimeInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timeInterval",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: tokens.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tokens",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotTokensVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotTokensVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Tokens = append(params.Tokens, paramsDotTokensVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokens",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetReturnsParams is parameters of GetReturns operation.
type GetReturnsParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// Comma separated list of account addresses.
	Accounts []string
	// The address of the token/currency used as the currency for price. Defaults to USD (address
	// `0x0000000000000000000000000000000000000348`).
	QuoteAddress OptString
	// Block number of the portfolio. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetReturnsParams(packed middleware.Parameters) (params GetReturnsParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "accounts",
			In:   "path",
		}
		params.Accounts = packed[key].([]string)
	}
	{
		key := middleware.ParameterKey{
			Name: "quoteAddress",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.QuoteAddress = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetReturnsParams(args [2]string, argsEscaped bool, r *http.Request) (params GetReturnsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: accounts.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "accounts",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotAccountsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotAccountsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Accounts = append(params.Accounts, paramsDotAccountsVal)
					return nil
				})
			}(); err != nil {
				return err
			}
			if err := func() error {
				if params.Accounts == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "accounts",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: quoteAddress.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "quoteAddress",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQuoteAddressVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQuoteAddressVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.QuoteAddress.SetTo(paramsDotQuoteAddressVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "quoteAddress",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenAbiParams is parameters of GetTokenAbi operation.
type GetTokenAbiParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Block number of the ABI. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetTokenAbiParams(packed middleware.Parameters) (params GetTokenAbiParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenAbiParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenAbiParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenBalanceParams is parameters of GetTokenBalance operation.
type GetTokenBalanceParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// The address of the account for which balance of the token will be fetched.
	AccountAddress string
	// The address of the token/currency used as the currency of the returned price. Defaults to USD
	// (address `0x0000000000000000000000000000000000000348`).
	QuoteAddress OptString
	// Scale balance by token decimals. Defaults to `true`.
	Scaled OptBool
	// Block number of the balance. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetTokenBalanceParams(packed middleware.Parameters) (params GetTokenBalanceParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "accountAddress",
			In:   "query",
		}
		params.AccountAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "quoteAddress",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.QuoteAddress = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "scaled",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Scaled = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenBalanceParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenBalanceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: accountAddress.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "accountAddress",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountAddress = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "accountAddress",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: quoteAddress.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "quoteAddress",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQuoteAddressVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQuoteAddressVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.QuoteAddress.SetTo(paramsDotQuoteAddressVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "quoteAddress",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: scaled.
	{
		val := bool(true)
		params.Scaled.SetTo(val)
	}
	// Decode query: scaled.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "scaled",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotScaledVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotScaledVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Scaled.SetTo(paramsDotScaledVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "scaled",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenBalanceHistoricalParams is parameters of GetTokenBalanceHistorical operation.
type GetTokenBalanceHistoricalParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Start block number of the balance. Defaults to token's creation block.
	StartBlockNumber OptFloat64
	// End block number of the balance. Defaults to the latest block.
	EndBlockNumber OptFloat64
	// Number of blocks between each data point.
	BlockInterval OptFloat64
	// Start timestamp of a block number can be specified instead of start block number. Finds a block at
	// or before the number of seconds since January 1, 1970.
	StartTimestamp OptFloat64
	// End timestamp of a block number can be specified instead of end block number. Finds a block at or
	// before the number of seconds since January 1, 1970.
	EndTimestamp OptFloat64
	// Can be specified instead of blockInterval. Should be in seconds. Defaults to 86,400.
	TimeInterval OptFloat64
	// The address of the account for which balance of the token will be fetched.
	AccountAddress string
	// The address of the token/currency used as the currency of the returned price. Defaults to USD
	// (address `0x0000000000000000000000000000000000000348`).
	QuoteAddress OptString
	// Scale balance by token decimals. Defaults to `true`.
	Scaled OptBool
}

func unpackGetTokenBalanceHistoricalParams(packed middleware.Parameters) (params GetTokenBalanceHistoricalParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "startBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockInterval = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "startTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timeInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TimeInterval = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "accountAddress",
			In:   "query",
		}
		params.AccountAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "quoteAddress",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.QuoteAddress = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "scaled",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Scaled = v.(OptBool)
		}
	}
	return params
}

func decodeGetTokenBalanceHistoricalParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenBalanceHistoricalParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: startBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartBlockNumber.SetTo(paramsDotStartBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndBlockNumber.SetTo(paramsDotEndBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockInterval.SetTo(paramsDotBlockIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockInterval",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: startTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTimestamp.SetTo(paramsDotStartTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndTimestamp.SetTo(paramsDotEndTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timeInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimeIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeInterval.SetTo(paramsDotTimeIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.TimeInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timeInterval",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: accountAddress.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "accountAddress",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AccountAddress = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "accountAddress",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: quoteAddress.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "quoteAddress",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQuoteAddressVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQuoteAddressVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.QuoteAddress.SetTo(paramsDotQuoteAddressVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "quoteAddress",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: scaled.
	{
		val := bool(true)
		params.Scaled.SetTo(val)
	}
	// Decode query: scaled.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "scaled",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotScaledVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotScaledVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Scaled.SetTo(paramsDotScaledVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "scaled",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenCreationBlockParams is parameters of GetTokenCreationBlock operation.
type GetTokenCreationBlockParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Block number of the token. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetTokenCreationBlockParams(packed middleware.Parameters) (params GetTokenCreationBlockParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenCreationBlockParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenCreationBlockParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenDecimalsParams is parameters of GetTokenDecimals operation.
type GetTokenDecimalsParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Block number of the decimals. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetTokenDecimalsParams(packed middleware.Parameters) (params GetTokenDecimalsParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenDecimalsParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenDecimalsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenHoldersParams is parameters of GetTokenHolders operation.
type GetTokenHoldersParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// The size of the returned page. Do not change this from page to page when using a cursor.
	PageSize float64
	// The cursor from the results of a previous page. Use empty string (or undefined/null) for first
	// page.
	Cursor OptNilString
	// The address of the token/currency used as the currency of the returned price. Defaults to USD
	// (address `0x0000000000000000000000000000000000000348`).
	QuoteAddress OptString
	// Scale holders' balance by token decimals. Defaults to `true`.
	Scaled OptBool
	// Block number of the balance. Defaults to the latest block. Do not change this from page to page
	// when using a cursor.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetTokenHoldersParams(packed middleware.Parameters) (params GetTokenHoldersParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "pageSize",
			In:   "query",
		}
		params.PageSize = packed[key].(float64)
	}
	{
		key := middleware.ParameterKey{
			Name: "cursor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Cursor = v.(OptNilString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "quoteAddress",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.QuoteAddress = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "scaled",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Scaled = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenHoldersParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenHoldersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: pageSize.
	{
		val := float64(100)
		params.PageSize = val
	}
	// Decode query: pageSize.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToFloat64(val)
				if err != nil {
					return err
				}

				params.PageSize = c
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.Float{
					MinSet:        true,
					Min:           1,
					MaxSet:        true,
					Max:           5000,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    nil,
				}).Validate(float64(params.PageSize)); err != nil {
					return errors.Wrap(err, "float")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "pageSize",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: cursor.
	{
		params.Cursor.Null = true
	}
	// Decode query: cursor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "cursor",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: quoteAddress.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "quoteAddress",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQuoteAddressVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQuoteAddressVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.QuoteAddress.SetTo(paramsDotQuoteAddressVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "quoteAddress",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: scaled.
	{
		val := bool(true)
		params.Scaled.SetTo(val)
	}
	// Decode query: scaled.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "scaled",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotScaledVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotScaledVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Scaled.SetTo(paramsDotScaledVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "scaled",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenHoldersCountParams is parameters of GetTokenHoldersCount operation.
type GetTokenHoldersCountParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Block number of the balance. Defaults to the latest block. Do not change this from page to page
	// when using a cursor.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetTokenHoldersCountParams(packed middleware.Parameters) (params GetTokenHoldersCountParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenHoldersCountParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenHoldersCountParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenHoldersCountHistoricalParams is parameters of GetTokenHoldersCountHistorical operation.
type GetTokenHoldersCountHistoricalParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Start block number of the balance. Defaults to token's creation block.
	StartBlockNumber OptFloat64
	// End block number of the balance. Defaults to the latest block.
	EndBlockNumber OptFloat64
	// Number of blocks between each data point.
	BlockInterval OptFloat64
	// Start timestamp of a block number can be specified instead of start block number. Finds a block at
	// or before the number of seconds since January 1, 1970.
	StartTimestamp OptFloat64
	// End timestamp of a block number can be specified instead of end block number. Finds a block at or
	// before the number of seconds since January 1, 1970.
	EndTimestamp OptFloat64
	// Can be specified instead of blockInterval. Should be in seconds. Defaults to 86,400.
	TimeInterval OptFloat64
}

func unpackGetTokenHoldersCountHistoricalParams(packed middleware.Parameters) (params GetTokenHoldersCountHistoricalParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "startBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockInterval = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "startTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timeInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TimeInterval = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenHoldersCountHistoricalParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenHoldersCountHistoricalParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: startBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartBlockNumber.SetTo(paramsDotStartBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndBlockNumber.SetTo(paramsDotEndBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockInterval.SetTo(paramsDotBlockIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockInterval",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: startTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTimestamp.SetTo(paramsDotStartTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndTimestamp.SetTo(paramsDotEndTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timeInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimeIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeInterval.SetTo(paramsDotTimeIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.TimeInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timeInterval",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenLogoParams is parameters of GetTokenLogo operation.
type GetTokenLogoParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Block number of the logo. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetTokenLogoParams(packed middleware.Parameters) (params GetTokenLogoParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenLogoParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenLogoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenMetadataParams is parameters of GetTokenMetadata operation.
type GetTokenMetadataParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Block number of the metadata. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetTokenMetadataParams(packed middleware.Parameters) (params GetTokenMetadataParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenMetadataParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenMetadataParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenNameParams is parameters of GetTokenName operation.
type GetTokenNameParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Block number of the name. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetTokenNameParams(packed middleware.Parameters) (params GetTokenNameParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenNameParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenNameParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenPriceParams is parameters of GetTokenPrice operation.
type GetTokenPriceParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// The address of the token/currency used as the currency of the returned price. Defaults to USD
	// (address `0x0000000000000000000000000000000000000348`).
	QuoteAddress OptString
	// Block number of the price quote. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetTokenPriceParams(packed middleware.Parameters) (params GetTokenPriceParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "quoteAddress",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.QuoteAddress = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenPriceParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenPriceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: quoteAddress.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "quoteAddress",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQuoteAddressVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQuoteAddressVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.QuoteAddress.SetTo(paramsDotQuoteAddressVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "quoteAddress",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenPriceHistoricalParams is parameters of GetTokenPriceHistorical operation.
type GetTokenPriceHistoricalParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Start block number of the balance. Defaults to token's creation block.
	StartBlockNumber OptFloat64
	// End block number of the balance. Defaults to the latest block.
	EndBlockNumber OptFloat64
	// Number of blocks between each data point.
	BlockInterval OptFloat64
	// Start timestamp of a block number can be specified instead of start block number. Finds a block at
	// or before the number of seconds since January 1, 1970.
	StartTimestamp OptFloat64
	// End timestamp of a block number can be specified instead of end block number. Finds a block at or
	// before the number of seconds since January 1, 1970.
	EndTimestamp OptFloat64
	// Can be specified instead of blockInterval. Should be in seconds. Defaults to 86,400.
	TimeInterval OptFloat64
	// The address of the token/currency used as the currency of the returned price. Defaults to USD
	// (address `0x0000000000000000000000000000000000000348`).
	QuoteAddress OptString
}

func unpackGetTokenPriceHistoricalParams(packed middleware.Parameters) (params GetTokenPriceHistoricalParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "startBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockInterval = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "startTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timeInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TimeInterval = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "quoteAddress",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.QuoteAddress = v.(OptString)
		}
	}
	return params
}

func decodeGetTokenPriceHistoricalParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenPriceHistoricalParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: startBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartBlockNumber.SetTo(paramsDotStartBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndBlockNumber.SetTo(paramsDotEndBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockInterval.SetTo(paramsDotBlockIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockInterval",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: startTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTimestamp.SetTo(paramsDotStartTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndTimestamp.SetTo(paramsDotEndTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timeInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimeIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeInterval.SetTo(paramsDotTimeIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.TimeInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timeInterval",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: quoteAddress.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "quoteAddress",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQuoteAddressVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQuoteAddressVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.QuoteAddress.SetTo(paramsDotQuoteAddressVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "quoteAddress",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenSymbolParams is parameters of GetTokenSymbol operation.
type GetTokenSymbolParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Block number of the symbol. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetTokenSymbolParams(packed middleware.Parameters) (params GetTokenSymbolParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenSymbolParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenSymbolParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenTotalSupplyParams is parameters of GetTokenTotalSupply operation.
type GetTokenTotalSupplyParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Ethereum
	// Mainnet<br/>`10` - Optimism<br/>`56` - BSC<br/>`137` - Polygon Mainnet<br/>`250` - Fantom
	// Opera<br/>`42161` - Arbitrum One<br/>`43114` - Avalanche C-Chain.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Block number of the total supply. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
	// Scale total supply by token decimals. Defaults to `true`.
	Scaled OptBool
}

func unpackGetTokenTotalSupplyParams(packed middleware.Parameters) (params GetTokenTotalSupplyParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "scaled",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Scaled = v.(OptBool)
		}
	}
	return params
}

func decodeGetTokenTotalSupplyParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenTotalSupplyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: scaled.
	{
		val := bool(true)
		params.Scaled.SetTo(val)
	}
	// Decode query: scaled.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "scaled",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotScaledVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotScaledVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Scaled.SetTo(paramsDotScaledVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "scaled",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenTotalSupplyHistoricalParams is parameters of GetTokenTotalSupplyHistorical operation.
type GetTokenTotalSupplyHistoricalParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Start block number of the balance. Defaults to token's creation block.
	StartBlockNumber OptFloat64
	// End block number of the balance. Defaults to the latest block.
	EndBlockNumber OptFloat64
	// Number of blocks between each data point.
	BlockInterval OptFloat64
	// Start timestamp of a block number can be specified instead of start block number. Finds a block at
	// or before the number of seconds since January 1, 1970.
	StartTimestamp OptFloat64
	// End timestamp of a block number can be specified instead of end block number. Finds a block at or
	// before the number of seconds since January 1, 1970.
	EndTimestamp OptFloat64
	// Can be specified instead of blockInterval. Should be in seconds. Defaults to 86,400.
	TimeInterval OptFloat64
	// Scale total supply by token decimals. Defaults to `true`.
	Scaled OptBool
}

func unpackGetTokenTotalSupplyHistoricalParams(packed middleware.Parameters) (params GetTokenTotalSupplyHistoricalParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "startBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockInterval = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "startTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timeInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TimeInterval = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "scaled",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Scaled = v.(OptBool)
		}
	}
	return params
}

func decodeGetTokenTotalSupplyHistoricalParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenTotalSupplyHistoricalParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: startBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartBlockNumber.SetTo(paramsDotStartBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndBlockNumber.SetTo(paramsDotEndBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockInterval.SetTo(paramsDotBlockIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockInterval",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: startTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTimestamp.SetTo(paramsDotStartTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndTimestamp.SetTo(paramsDotEndTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timeInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimeIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeInterval.SetTo(paramsDotTimeIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.TimeInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timeInterval",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: scaled.
	{
		val := bool(true)
		params.Scaled.SetTo(val)
	}
	// Decode query: scaled.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "scaled",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotScaledVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotScaledVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Scaled.SetTo(paramsDotScaledVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "scaled",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenVolumeParams is parameters of GetTokenVolume operation.
type GetTokenVolumeParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Scale volume by token decimals. Defaults to `true`.
	Scaled OptBool
	// Start block number of duration for which token volume will be computed.
	StartBlockNumber OptFloat64
	// Start block number of duration for which token volume will be computed. Defaults to the latest
	// block.
	EndBlockNumber OptFloat64
	// Start timestamp of a block number can be specified instead of start block number. Finds a block at
	// or before the number of seconds since January 1, 1970.
	StartTimestamp OptFloat64
	// End timestamp of a block number can be specified instead of end block number. Finds a block at or
	// before the number of seconds since January 1, 1970.
	EndTimestamp OptFloat64
}

func unpackGetTokenVolumeParams(packed middleware.Parameters) (params GetTokenVolumeParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "scaled",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Scaled = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "startBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "startTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndTimestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenVolumeParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenVolumeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: scaled.
	{
		val := bool(true)
		params.Scaled.SetTo(val)
	}
	// Decode query: scaled.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "scaled",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotScaledVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotScaledVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Scaled.SetTo(paramsDotScaledVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "scaled",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: startBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartBlockNumber.SetTo(paramsDotStartBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndBlockNumber.SetTo(paramsDotEndBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: startTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTimestamp.SetTo(paramsDotStartTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndTimestamp.SetTo(paramsDotEndTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetTokenVolumeHistoricalParams is parameters of GetTokenVolumeHistorical operation.
type GetTokenVolumeHistoricalParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// The address of the token requested.
	TokenAddress string
	// Scale volume by token decimals. Defaults to `true`.
	Scaled OptBool
	// Start block number of duration for which token volume will be computed.
	StartBlockNumber OptFloat64
	// Start block number of duration for which token volume will be computed. Defaults to the latest
	// block.
	EndBlockNumber OptFloat64
	// Start timestamp of a block number can be specified instead of start block number. Finds a block at
	// or before the number of seconds since January 1, 1970.
	StartTimestamp OptFloat64
	// End timestamp of a block number can be specified instead of end block number. Finds a block at or
	// before the number of seconds since January 1, 1970.
	EndTimestamp OptFloat64
	// Number of blocks between each data point.
	BlockInterval OptFloat64
	// Can be specified instead of blockInterval. Should be in seconds. Defaults to 86,400.
	TimeInterval OptFloat64
}

func unpackGetTokenVolumeHistoricalParams(packed middleware.Parameters) (params GetTokenVolumeHistoricalParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokenAddress",
			In:   "path",
		}
		params.TokenAddress = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "scaled",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Scaled = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "startBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "startTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockInterval = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timeInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TimeInterval = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetTokenVolumeHistoricalParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTokenVolumeHistoricalParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tokenAddress.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tokenAddress",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TokenAddress = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokenAddress",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: scaled.
	{
		val := bool(true)
		params.Scaled.SetTo(val)
	}
	// Decode query: scaled.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "scaled",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotScaledVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotScaledVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Scaled.SetTo(paramsDotScaledVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "scaled",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: startBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartBlockNumber.SetTo(paramsDotStartBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndBlockNumber.SetTo(paramsDotEndBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: startTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTimestamp.SetTo(paramsDotStartTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndTimestamp.SetTo(paramsDotEndTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockInterval.SetTo(paramsDotBlockIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockInterval",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timeInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimeIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeInterval.SetTo(paramsDotTimeIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.TimeInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    nil,
						}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timeInterval",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetValueParams is parameters of GetValue operation.
type GetValueParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// Comma separated list of account addresses.
	Accounts []string
	// Comma separated list of token addresses. If no tokens are provided return positions for all tokens
	// with non-zero balances.
	Tokens []string
	// The address of the token/currency used as the currency of the returned price. Defaults to USD
	// (address `0x0000000000000000000000000000000000000348`).
	QuoteAddress OptString
	// Set `true` to include positions. Defaults to `false`.
	IncludePositions OptBool
	// Block number of the portfolio. Defaults to the latest block.
	BlockNumber OptFloat64
	// Timestamp of a block number can be specified instead of a block number. Finds a block at or before
	// the number of seconds since January 1, 1970.
	Timestamp OptFloat64
}

func unpackGetValueParams(packed middleware.Parameters) (params GetValueParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "accounts",
			In:   "path",
		}
		params.Accounts = packed[key].([]string)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokens",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Tokens = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "quoteAddress",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.QuoteAddress = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "includePositions",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludePositions = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Timestamp = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetValueParams(args [2]string, argsEscaped bool, r *http.Request) (params GetValueParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: accounts.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "accounts",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotAccountsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotAccountsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Accounts = append(params.Accounts, paramsDotAccountsVal)
					return nil
				})
			}(); err != nil {
				return err
			}
			if err := func() error {
				if params.Accounts == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "accounts",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: tokens.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tokens",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotTokensVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotTokensVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Tokens = append(params.Tokens, paramsDotTokensVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokens",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: quoteAddress.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "quoteAddress",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQuoteAddressVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQuoteAddressVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.QuoteAddress.SetTo(paramsDotQuoteAddressVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "quoteAddress",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: includePositions.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "includePositions",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludePositionsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIncludePositionsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IncludePositions.SetTo(paramsDotIncludePositionsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "includePositions",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockNumber.SetTo(paramsDotBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Timestamp.SetTo(paramsDotTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Timestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timestamp",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetValueHistoricalParams is parameters of GetValueHistorical operation.
type GetValueHistoricalParams struct {
	// Chain identifier. This endpoint supports the following chains<br/><br/>`1` - Mainnet.
	ChainId int
	// Comma separated list of account addresses.
	Accounts []string
	// Comma separated list of token addresses. If no tokens are provided return positions for all tokens
	// with non-zero balances.
	Tokens []string
	// The address of the token/currency used as the currency of the returned price. Defaults to USD
	// (address `0x0000000000000000000000000000000000000348`).
	QuoteAddress OptString
	// Set `true` to include positions. Defaults to `false`.
	IncludePositions OptBool
	// Start block number. Required.
	StartBlockNumber OptFloat64
	// End block number of the balance. Defaults to the latest block.
	EndBlockNumber OptFloat64
	// Number of blocks between each data point.
	BlockInterval OptFloat64
	// Start timestamp of a block number can be specified instead of start block number. Finds a block at
	// or before the number of seconds since January 1, 1970.
	StartTimestamp OptFloat64
	// End timestamp of a block number can be specified instead of end block number. Finds a block at or
	// before the number of seconds since January 1, 1970.
	EndTimestamp OptFloat64
	// Can be specified instead of blockInterval. Should be in seconds. Defaults to 86,400.
	TimeInterval OptFloat64
}

func unpackGetValueHistoricalParams(packed middleware.Parameters) (params GetValueHistoricalParams) {
	{
		key := middleware.ParameterKey{
			Name: "chainId",
			In:   "path",
		}
		params.ChainId = packed[key].(int)
	}
	{
		key := middleware.ParameterKey{
			Name: "accounts",
			In:   "path",
		}
		params.Accounts = packed[key].([]string)
	}
	{
		key := middleware.ParameterKey{
			Name: "tokens",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Tokens = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "quoteAddress",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.QuoteAddress = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "includePositions",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludePositions = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "startBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endBlockNumber",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndBlockNumber = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "blockInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BlockInterval = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "startTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "endTimestamp",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndTimestamp = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "timeInterval",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TimeInterval = v.(OptFloat64)
		}
	}
	return params
}

func decodeGetValueHistoricalParams(args [2]string, argsEscaped bool, r *http.Request) (params GetValueHistoricalParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: chainId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "chainId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ChainId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "chainId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: accounts.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "accounts",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotAccountsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotAccountsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Accounts = append(params.Accounts, paramsDotAccountsVal)
					return nil
				})
			}(); err != nil {
				return err
			}
			if err := func() error {
				if params.Accounts == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "accounts",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: tokens.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tokens",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotTokensVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotTokensVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Tokens = append(params.Tokens, paramsDotTokensVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tokens",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: quoteAddress.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "quoteAddress",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQuoteAddressVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQuoteAddressVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.QuoteAddress.SetTo(paramsDotQuoteAddressVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "quoteAddress",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: includePositions.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "includePositions",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludePositionsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotIncludePositionsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IncludePositions.SetTo(paramsDotIncludePositionsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "includePositions",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: startBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartBlockNumber.SetTo(paramsDotStartBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endBlockNumber.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endBlockNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndBlockNumberVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndBlockNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndBlockNumber.SetTo(paramsDotEndBlockNumberVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndBlockNumber.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endBlockNumber",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: blockInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "blockInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBlockIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotBlockIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BlockInterval.SetTo(paramsDotBlockIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.BlockInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "blockInterval",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: startTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTimestamp.SetTo(paramsDotStartTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.StartTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "startTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: endTimestamp.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endTimestamp",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndTimestampVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotEndTimestampVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndTimestamp.SetTo(paramsDotEndTimestampVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.EndTimestamp.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "endTimestamp",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: timeInterval.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeInterval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeIntervalVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotTimeIntervalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeInterval.SetTo(paramsDotTimeIntervalVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.TimeInterval.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timeInterval",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}
